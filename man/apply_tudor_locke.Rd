% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/apply_tudor_locke.R
\name{apply_tudor_locke}
\alias{apply_tudor_locke}
\title{Apply the Tudor-Locke algorithm}
\usage{
apply_tudor_locke(agdb, n_bedtime_start = 5, n_wake_time_end = 10,
  min_sleep_period = 160, max_sleep_period = 1440, min_nonzero_epochs = 0)
}
\arguments{
\item{agdb}{A \code{tibble} (\code{tbl}) of activity data (at least) an \code{epochlength} attribute. The epoch length must be 60 seconds. Each epoch should be scored as asleep (S) or awake (W), using the Sadeh, the Cole-Kripke or a custom algorithm.}

\item{n_bedtime_start}{Bedtime definition, in minutes. The default is 5.}

\item{n_wake_time_end}{Wake time definition, in minutes. The default is 10.}

\item{min_sleep_period}{Min sleep period length, in minutes. The default is 160.}

\item{max_sleep_period}{Max sleep period length, in minutes. The default is 1440 (24 hours).}

\item{min_nonzero_epochs}{Min number of epochs with non-zero activity. The default is 0.}
}
\value{
A summary \code{tibble} of the detected sleep periods. If the activity data is grouped, then sleep periods are detected separately for each group.
\describe{
  \item{in_bed_timestamp}{The first minute of the bedtime.}
  \item{out_bed_timestamp}{The first minute of wake time.}
  \item{onset_timestamp}{The first minute that the algorithm scores "asleep".}
  \item{latency}{The time elapsed between bedtime and sleep onset. By the definition of Tudor-Locke, latency is 0.}
  \item{total_counts}{The sum of activity counts for the entire sleep period.}
  \item{efficiency}{The number of sleep minutes divided by the bedtime  minutes.}
  \item{time_in_bed}{The duration of the sleep period, in minutes.}
  \item{time_asleep}{Total Sleep Time (TST) – The number of minutes scored as "asleep" during the sleep period.}
  \item{time_awake}{Wake after Sleep Onset (WASO) – The number of minutes scored as "awake", minus the sleep latency, during the sleep period.}
  \item{awakenings}{The number of awakening episodes.}
  \item{ave_awakening}{The average length, in minutes, of all awakening episodes.}
  \item{movement_index}{Proportion of awake time out of the total time in bed, in percentages.}
  \item{fragmentation_index}{Proportion of one-minute sleep bouts out of the number of sleep bouts of any length, in percentages.}
  \item{sleep_fragmentation_index}{Sleep fragmentation index – The sum of the movement and fragmentation indices.}
}
}
\description{
The Tudor-Locke algorithm detects periods of time in bed and, for each period, computes sleep quality metrics such as total minutes in bed, total sleep time, number and average length of awakenings, movement and fragmentation index.
}
\details{
Once each one-minute epoch is labeled as asleep (S) or awake (W), we can use the Tudor-Locke algorithm to detect periods of \emph{bedtime} and \emph{sleep time}. By definition, sleep time < bedtime since one can be in bed and not sleeping.

Bedtime is (the first minute of) \code{n_bedtime_start} consecutive epochs/minutes labeled S. Similarly, wake time is (the first minute of) of \code{n_wake_time_end} consecutive epochs/minutes labeled W, after a period of sleep. The time block between bedtime and wake time is one sleep period, if the time elapsed is at least \code{min_sleep_period} minutes. There can be multiple sleep periods in 24 hours but a sleep period cannot be longer than \code{max_sleep_period} minutes.

For each sleep period, the algorithm calculates several measures of sleep quality such as time asleep and time awake, number and average length of awakenings, and movement and fragmentation indices.
}
\examples{
file <- system.file("extdata", "GT3XPlus-RawData-Day01-10sec.agd",
                    package = "actigraph.sleepr")

library("lubridate")
library("dplyr")

agdb_10s <- read_agd(file)
agdb_60s <- collapse_epochs(agdb_10s, 60) \%>\%
  filter(day(timestamp) == 28)

# Detect sleep periods using Sadeh as the sleep/awake algorithm
# and Tudor-Locke as the sleep period algorithm
agdb_60s_scored <- apply_sadeh(agdb_60s)
agdb_60s_sleep <- apply_tudor_locke(agdb_60s_scored, min_sleep_period = 60)
agdb_60s_sleep

# Group and summarize by an extra varible: hour < 6 or not
# This grouping is chosen not because it is interesting but to split
# one longer sleep period in two, for illustration of how grouping works
agdb_60s <- agdb_60s \%>\%
  mutate(hour_lt6 = hour(timestamp) < 6) \%>\%
  group_by(hour_lt6)
agdb_60s_scored <- apply_sadeh(agdb_60s)
agdb_60s_sleep <- apply_tudor_locke(agdb_60s_scored, min_sleep_period = 60)
agdb_60s_sleep
}
\references{
C Tudor-Locke, TV Barreira, JM Schuna Jr, EF Mire and PT Katzmarzyk. Fully automated waist-worn accelerometer algorithm for detecting children's sleep-period time separate from 24-h physical activity or sedentary behaviors. \emph{Applied Physiology}, Nutrition, and Metabolism, 39(1):53–57, 2014.

ActiLife 6 User's Manual by the ActiGraph Software Department. 04/03/2012.
}
\seealso{
\code{\link{apply_sadeh}}, \code{\link{apply_cole_kripke}}
}

