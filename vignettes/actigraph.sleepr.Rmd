---
title: "Sleep detection from ActiGraph data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Sleep detection from ActiGraph data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r , echo = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE,
                      collapse = TRUE, comment = "#>")
pckg <- c("actigraph.sleepr", "dplyr", "lubridate", "ggplot2")
inst <- suppressMessages(lapply(pckg, library, character.only = TRUE))
theme_set(theme_light())
```

The `actigraph.sleepr` package implements functions to read AGD files and to apply three standard sleep algorithms: Sadeh, Cole-Kripke and Tudor-Locke. GT3X+ / ActiSleep+ sample data for illustration is taken from [ActiGraph's online documentation](https://actigraph.desk.com).

```{r }
file_10s <- system.file("extdata", "GT3XPlus-RawData-Day01-10sec.agd",
                        package = "actigraph.sleepr")
```

### Read AGD file(s)

An AGD file is an SQLite database file exported by an ActiGraph device, which contains five tables: settings, data, sleep, awakenings and filters. The sleep and awakenings tables are empty unless the ActiLife tool has been used to analyze the activity counts to detect sleep. See the [ActiLife 6 User manual](http://actigraphcorp.com/support/manuals/actilife-6-manual/).

We can load all five tables in a list using the `read_agd_raw` function.

```{r }
# UTC (Coordinated Universal Time) is the default time zone
agdb_10s_raw <- read_agd_raw(file_10s, tz = "UTC")
class(agdb_10s_raw)
names(agdb_10s_raw)
agdb_10s_raw
```

Alternatively, we can use the `read_agd` function to process the raw activity measurements into a more convenient format: a `dplyr` data frame (a tibble) of timestamped activity counts, whose attributes are the device settings.

```{r}
agdb_10s <- read_agd(file_10s, tz = "UTC")
str(agdb_10s)
```

Since the data is stored in a tibble, we can use the `dplyr` verbs to manipulate the data. For example, let's compute the vector magnitude from the axis variables. The formula for vector magnitude (norm) is straightforward. Let $x$, $y$ and $z$ be the three axis measurements, `axis1`, `axis2` and `axis3`, respectively. Then the magnitude of the movement vector is $$\sqrt{x^2 + y^2 + z^2}$$.

```{r }
agdb_10s %>%
  rename(y = axis1, x = axis2, z = axis3) %>%
  mutate(magnitude = sqrt(x^2 + y^2 + z^2))
```

```{r fig.width = 7, fig.height = 4, fig.cap = "24 hours of activity data taken with an ActiGraph device at a frequency of 10 sec."}
ggplot(agdb_10s, aes(timestamp, axis1)) +
  geom_line() +
  labs(x = "", y = "activity")
```

### Reintegrate from 10s to 60s epochs

The standard algorithms for converting activity measurements into asleep/awake indicators -- Sadeh and Cole-Kripke -- were developed for 60s epochs. If the data is in smaller epochs, we need to collapse or aggregate the epochs. The example data is in 10s epochs. So we aggregate the epochs from 10 sec to 60 sec by adding the counts for the six consecutive 10s epochs that fall in the same 60s epoch.

```{r }
# Collapse epochs from 10 sec to 60 sec by summing
agdb_60s <- collapse_epochs(agdb_10s, 60)
agdb_60s
```

```{r fig.width = 7, fig.height = 4, fig.cap = "24 hours of activity data taken with an ActiGraph device at a frequency of 10 sec and then aggregated into 60 sec epochs."}
ggplot(agdb_60s, aes(timestamp, axis1)) +
  geom_line() +
  labs(x = "", y = "activity")
```

### Process a batch of AGD files

We can load each AGD file in a directory, collapse from 10s to 60s and save the integrated activity data with a few lines of code.

```{r , eval = FALSE}
library("readr")
library("tools")

# Construct a path to the directory which contains the raw AGD files
path_in <- system.file("extdata", package = "actigraph.sleepr")
# And a path to the directory to contain the processed CSV files
path_out <- path.expand("~")
# Finally, ge the list of available AGD files to process
filenames <- list.files(path_in, pattern = ".agd", full.names = FALSE)
basenames <- file_path_sans_ext(filenames)

for (basename in basenames) {
  file_in <- file.path(path_in, paste0(basename, ".agd"))
  file_out <- file.path(path_out, paste0(basename, ".csv"))
  agdb <- read_agd(file_in)
  write_csv(agdb, file_out)
}
```

### Apply the Sadeh algorithm

The Sadeh sleep scoring algorithm is primarily used for younger adolescents as the supporting research was performed on children and young adults. It requires 60s epochs and uses an 11-minute window that includes the five previous and five future epochs. The `apply_sadeh` function in the `actigraph.sleepr` package implements the algorithm as described in the ActiGraph user manual.

```{r , echo = TRUE}
agdb_sadeh <- apply_sadeh(agdb_60s)
```

Here are the details. The Sadeh algorithm uses the y-axis (axis 1) counts; epoch counts over 300 are set to 300. The sleep index (SI) is defined as

```
SI = 7.601 - (0.065 * AVG) - (1.08 * NATS) - (0.056 * SD) - (0.703 * LG)
```

where at epoch t:

AVG
 : the arithmetic mean (average) of the activity counts in an 11-epoch window centered at t;
 
NATS
 : the number of epochs in this 11-epoch window which have counts >= 50 and < 100;
 
SD:
 : the standard deviation of the counts in a 6-epoch window that includes t and the five preceding epochs;
 
LG
 : the natural (base e) logarithm of the activity at epoch t. To avoid taking the log of 0, we add 1 to the count.

The time series of activity counts is padded with zeros as necessary, at the beginning and at the end, to compute the three functions AVG, SD, NATS within a rolling window. Finally, the state is awake (W) if the sleep index SI is greater than -4; otherwise the state is asleep (S).

```{r fig.width = 7, fig.height = 4, fig.cap = "The Sadeh algorithm infers whether the subject is sleeping or not, for each one-minute epoch. A blue dot means awake (W), a red dot means asleep (S). The algorithm thresholds the raw activity counts at 300."}
ggplot(agdb_sadeh, aes(timestamp, count)) +
  geom_line() +
  geom_point(aes(timestamp, 300 * recode(state, S = 0, W = 1), 
                 color = state), shape = 1) +
  labs(x = "", y = "(scaled) activity") +
  guides(color = FALSE)
```

### Apply the Cole-Kripke algorithm

The Cole-Kripke sleep scoring algorithm is primarily used for adult populations as the supporting research was performed on subjects ranging from 35 to 65 years of age. Like the Sadeh algorithm, it requires 60s epochs and uses a 7-minute window that includes the four previous and two future epochs. The `apply_cole_kripke` function in the `actigraph.sleepr` package implements the algorithm as described in the ActiGraph user manual.

```{r , echo = TRUE}
agdb_colekripke <- apply_cole_kripke(agdb_60s)
```

Here are the details. The Cole-Kripke algorithm uses the y-axis (axis 1) counts; first epoch counts are divided by 100 and afterwards any scaled counts that are over 300 are set to 300. The sleep index (SI) is defined as

```
.001 * (106 * Epoch_prev4 + 54 * Epoch_prev3 + 58 * Epoch_prev2 + 76 * Epoch_prev1 +
        230 * Epoch +
         74 * Epoch_next1 + 67 * Epoch_next1)
```

where  at epoch t:

Epoch_prev(i)
 : the scaled activity count i epoch before t;
 
Epoch_next(i)
 : the scaled activity count i epochs after t.

The time series of activity counts is padded with zeros as necessary, at the beginning and at the end. Finally, the state is awake (W) if the sleep index SI is less than 1; otherwise the state is asleep (S).

```{r fig.width = 7, fig.height = 4, fig.cap = "The Cole-Kripke algorithm infers whether the subject is sleeping or not, for each one-minute epoch. A blue dot means awake (W), a red dot means asleep (S)."}
ggplot(agdb_colekripke, aes(timestamp, count)) +
  geom_line() +
  geom_point(aes(timestamp, 100 * recode(state, S = 0, W = 1), 
                 color = state), shape = 1) +
  labs(x = "", y = "(scaled) activity") +
  guides(color = FALSE)
```

What is the agreement between the Sadeh and Cole-Kripke asleep/awake algorithms, on the example dataset?

```{r }
table(agdb_sadeh$state, agdb_colekripke$state)
```

### Apply the Tudor-Locke algorithm

Once each one-minute epoch is labeled as asleep (S) or awake (W), we can use the Tudor-Locke algorithm to detect periods of time in bed and, for each period, to compute sleep quality metrics such as total minutes in bed, total sleep time, number and average length of awakenings, movement and fragmentation indices

The Tudor-Locke algorithm has several parameters:

n_bedtime_start	
 : Bedtime definition, in minutes. The default is 5.

n_wake_time_end	
 : Wake time definition, in minutes. The default is 10.

min_sleep_period	
 : Min sleep period length, in minutes. The default is 160.

max_sleep_period	
 : Max sleep period length, in minutes. The default is 1440 (24 hours).

min_nonzero_epochs	
 : Min number of epochs with non-zero activity. The default is 0.

Bedtime is (the first minute of) n_bedtime_start consecutive epochs/minutes labeled S. Similarly, wake time is (the first minute of) of n_wake_time_end consecutive epochs/minutes labeled W, after a period of sleep. The time block between bedtime and wake time is one sleep period, if the time elapsed is at least min_sleep_period minutes. There can be multiple sleep periods in 24 hours but a sleep period cannot be longer than max_sleep_period minutes.

```{r }
agdb_sleep <- apply_tudor_locke(agdb_sadeh)
agdb_sleep
```

in_bed_timestamp
 : The first minute of the bedtime.
 
out_bed_timestamp 
 : The last minute of wake time.

onset_timestamp
 : The first minute that the algorithm scores "asleep". By the definition of Tudor-Locke, the sleep onset occurs with the start of bedtime.

latency}
 : The time elapsed between bedtime and sleep onset. By the definition of Tudor-Locke, latency is 0.
 
total_counts
 : The sum of activity counts for the entire sleep period.

efficiency
 : The number of sleep minutes divided by the bedtime  minutes.
 
time_in_bed
 : The duration of the sleep period, in minutes.

time_asleep
 : Total Sleep Time (TST) – The number of minutes scored as "asleep" during the sleep period.
 
time_awake
 : Wake after Sleep Onset (WASO) – The number of minutes scored as "awake", minus the sleep latency, during the sleep period.

awakenings
 : The number of awakening episodes.

ave_awakening
 : The average length, in minutes, of all awakening episodes.

movement_index
 : Proportion of awake time out of the total time in bed, in percentages.

fragmentation_index
 : Proportion of one-minute sleep bouts out of the number of sleep bouts of any length, in percentages.

sleep_fragmentation_index
 : Sleep fragmentation index – The sum of the movement and fragmentation indices.

```{r fig.width = 7, fig.height = 4, fig.cap = "The Tudor-Locke algorithm detects sleep periods from asleep/awake status indicators per epoch. These are highlighted as gray rectangles."}
# Construct polygons to represent each sleep period visually
ymax <- max(agdb_60s$axis1)
ymin <- 0
p <- nrow(agdb_sleep)
id <- rep(seq(p), times = 4)
x <- c(rep(agdb_sleep$in_bed_timestamp, times = 2),
       rep(agdb_sleep$out_bed_timestamp, times = 2))
y <- rep(c(ymax, ymin, ymin, ymax), each = p)
sleep_periods <- data_frame(id = id, x = x, y = y)

ggplot(sleep_periods, aes(x, y)) + 
  geom_polygon(aes(group = id), fill = "lightgray") +
  geom_line(data = agdb_60s, aes(timestamp, axis1)) +
  labs(x = "", y = "activity")
```

